//! CodeTask parser for .code-task.md files.
//!
//! Parses structured markdown files generated by /code-task-generator
//! and converts them to Task objects for the execution DAG.

use crate::core::Task;
use crate::error::Result;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

/// Task complexity level.
///
/// Used for scheduling decisions and resource allocation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Complexity {
    /// Simple task, minimal effort required.
    Low,
    /// Standard task, typical effort required.
    #[default]
    Medium,
    /// Complex task, significant effort required.
    High,
}

impl std::fmt::Display for Complexity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Complexity::Low => write!(f, "low"),
            Complexity::Medium => write!(f, "medium"),
            Complexity::High => write!(f, "high"),
        }
    }
}

impl std::str::FromStr for Complexity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "low" => Ok(Complexity::Low),
            "medium" => Ok(Complexity::Medium),
            "high" => Ok(Complexity::High),
            _ => Err(format!("Unknown complexity: {}", s)),
        }
    }
}

/// A parsed code task from a .code-task.md file.
///
/// Contains all the structured information needed to create
/// a Task for the execution DAG.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeTask {
    /// Unique identifier derived from the file name.
    pub id: String,
    /// Path to the source .code-task.md file.
    pub file_path: PathBuf,
    /// Task title extracted from the markdown heading.
    pub title: String,
    /// Description of what the task should accomplish.
    pub description: String,
    /// List of acceptance criteria for the task.
    pub acceptance_criteria: Vec<String>,
    /// List of task IDs this task depends on.
    pub dependencies: Vec<String>,
    /// Estimated complexity of the task.
    pub complexity: Complexity,
}

impl CodeTask {
    /// Parse a CodeTask from a .code-task.md file.
    ///
    /// # Arguments
    /// * `path` - Path to the .code-task.md file
    ///
    /// # Returns
    /// A parsed CodeTask or an error if parsing fails
    ///
    /// # Example
    /// ```no_run
    /// use zen::core::CodeTask;
    /// use std::path::Path;
    ///
    /// let task = CodeTask::from_file(Path::new("task-01.code-task.md")).unwrap();
    /// println!("Task: {}", task.title);
    /// ```
    pub fn from_file(path: &Path) -> Result<Self> {
        let content = std::fs::read_to_string(path)?;

        Self::parse(&content, path)
    }

    /// Parse CodeTask from markdown content.
    fn parse(content: &str, path: &Path) -> Result<Self> {
        // Extract ID from filename
        let id = Self::extract_id_from_path(path);

        // Extract title from # Task: heading or first # heading
        let title = Self::extract_title(content).unwrap_or_else(|| id.clone());

        // Extract description from ## Description section
        let description = Self::extract_section(content, "Description").unwrap_or_default();

        // Extract acceptance criteria from ## Acceptance Criteria section
        let acceptance_criteria = Self::extract_list_items(content, "Acceptance Criteria");

        // Extract dependencies from ## Dependencies section
        let dependencies = Self::extract_dependencies(content);

        // Extract complexity from ## Metadata section
        let complexity = Self::extract_complexity(content).unwrap_or_default();

        Ok(CodeTask {
            id,
            file_path: path.to_path_buf(),
            title,
            description,
            acceptance_criteria,
            dependencies,
            complexity,
        })
    }

    /// Extract task ID from file path.
    fn extract_id_from_path(path: &Path) -> String {
        path.file_stem()
            .and_then(|s| s.to_str())
            .map(|s| {
                // Remove common suffixes like .code-task
                s.trim_end_matches(".code-task")
                    .trim_end_matches("-code-task")
                    .to_string()
            })
            .unwrap_or_else(|| "unknown".to_string())
    }

    /// Extract title from markdown content.
    fn extract_title(content: &str) -> Option<String> {
        // Try "# Task: <title>" format first
        let task_re = Regex::new(r"(?m)^#\s+Task:\s*(.+)$").unwrap();
        if let Some(caps) = task_re.captures(content) {
            return Some(caps[1].trim().to_string());
        }

        // Fall back to first # heading
        let heading_re = Regex::new(r"(?m)^#\s+(.+)$").unwrap();
        heading_re
            .captures(content)
            .map(|caps| caps[1].trim().to_string())
    }

    /// Extract a named section's content.
    fn extract_section(content: &str, section_name: &str) -> Option<String> {
        // Match ## Section Name and capture until next ## or end
        let pattern = format!(
            r"(?ms)^##\s+{}\s*\n(.*?)(?:^##\s|\z)",
            regex::escape(section_name)
        );
        let re = Regex::new(&pattern).unwrap();

        re.captures(content).map(|caps| {
            caps[1]
                .trim()
                .lines()
                .filter(|line| !line.trim().is_empty())
                .collect::<Vec<_>>()
                .join("\n")
        })
    }

    /// Extract list items from a named section.
    fn extract_list_items(content: &str, section_name: &str) -> Vec<String> {
        let section = match Self::extract_section(content, section_name) {
            Some(s) => s,
            None => return Vec::new(),
        };

        // Match numbered items (1. Item) or bulleted items (- Item, * Item)
        let list_re = Regex::new(r"(?m)^(?:\d+\.\s+|\-\s+|\*\s+)(.+)$").unwrap();

        list_re
            .captures_iter(&section)
            .map(|caps| caps[1].trim().to_string())
            .collect()
    }

    /// Extract dependencies from content.
    fn extract_dependencies(content: &str) -> Vec<String> {
        let section = match Self::extract_section(content, "Dependencies") {
            Some(s) => s,
            None => return Vec::new(),
        };

        // Look for task references like "task-01", "Task 1.1", etc.
        let task_ref_re = Regex::new(r"(?i)task[-\s]?(\d+(?:\.\d+)?|\w+[-\w]*)").unwrap();

        let mut deps = Vec::new();
        for caps in task_ref_re.captures_iter(&section) {
            let dep = caps[0].to_lowercase().replace(' ', "-");
            if !deps.contains(&dep) {
                deps.push(dep);
            }
        }

        deps
    }

    /// Extract complexity from Metadata section.
    fn extract_complexity(content: &str) -> Option<Complexity> {
        // Look for "**Complexity**: <value>" or "- **Complexity**: <value>"
        let complexity_re =
            Regex::new(r"(?mi)\*\*Complexity\*\*:\s*(Low|Medium|High)").unwrap();

        complexity_re
            .captures(content)
            .and_then(|caps| caps[1].parse().ok())
    }

    /// Scan a directory for .code-task.md files and parse them all.
    ///
    /// # Arguments
    /// * `dir` - Directory to scan for .code-task.md files
    ///
    /// # Returns
    /// A vector of parsed CodeTasks, sorted by filename
    ///
    /// # Example
    /// ```no_run
    /// use zen::core::CodeTask;
    /// use std::path::Path;
    ///
    /// let tasks = CodeTask::from_directory(Path::new(".sop/tasks")).unwrap();
    /// println!("Found {} tasks", tasks.len());
    /// ```
    pub fn from_directory(dir: &Path) -> Result<Vec<Self>> {
        if !dir.exists() {
            return Ok(Vec::new());
        }

        if !dir.is_dir() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::NotADirectory,
                format!("{} is not a directory", dir.display()),
            )
            .into());
        }

        let mut tasks = Vec::new();

        for entry in std::fs::read_dir(dir)? {
            let entry = entry?;

            let path = entry.path();

            // Check if it's a .code-task.md file
            if path.is_file() {
                let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
                if filename.ends_with(".code-task.md") || filename.contains("code-task") {
                    if let Ok(task) = Self::from_file(&path) {
                        tasks.push(task);
                    }
                }
            }
        }

        // Sort by filename for consistent ordering
        tasks.sort_by(|a, b| a.file_path.cmp(&b.file_path));

        Ok(tasks)
    }

    /// Convert this CodeTask to a Task for the execution DAG.
    ///
    /// Creates a new Task with the CodeTask's title as name
    /// and description field populated.
    ///
    /// # Example
    /// ```
    /// use zen::core::{CodeTask, Task};
    /// use std::path::PathBuf;
    ///
    /// let code_task = CodeTask {
    ///     id: "task-01".to_string(),
    ///     file_path: PathBuf::from("task-01.code-task.md"),
    ///     title: "Create User Model".to_string(),
    ///     description: "Implement the user data model".to_string(),
    ///     acceptance_criteria: vec!["Unit tests pass".to_string()],
    ///     dependencies: vec![],
    ///     complexity: zen::core::Complexity::Medium,
    /// };
    ///
    /// let task = code_task.to_task();
    /// assert_eq!(task.name, "Create User Model");
    /// ```
    pub fn to_task(&self) -> Task {
        Task::new(&self.title, &self.description)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    // Complexity tests

    #[test]
    fn test_complexity_default() {
        let complexity = Complexity::default();
        assert_eq!(complexity, Complexity::Medium);
    }

    #[test]
    fn test_complexity_display() {
        assert_eq!(format!("{}", Complexity::Low), "low");
        assert_eq!(format!("{}", Complexity::Medium), "medium");
        assert_eq!(format!("{}", Complexity::High), "high");
    }

    #[test]
    fn test_complexity_from_str() {
        assert_eq!("low".parse::<Complexity>().unwrap(), Complexity::Low);
        assert_eq!("medium".parse::<Complexity>().unwrap(), Complexity::Medium);
        assert_eq!("high".parse::<Complexity>().unwrap(), Complexity::High);
        assert_eq!("Low".parse::<Complexity>().unwrap(), Complexity::Low);
        assert_eq!("MEDIUM".parse::<Complexity>().unwrap(), Complexity::Medium);
        assert_eq!("HIGH".parse::<Complexity>().unwrap(), Complexity::High);
    }

    #[test]
    fn test_complexity_from_str_invalid() {
        assert!("invalid".parse::<Complexity>().is_err());
        assert!("".parse::<Complexity>().is_err());
    }

    #[test]
    fn test_complexity_serialization() {
        let complexity = Complexity::High;
        let json = serde_json::to_string(&complexity).unwrap();
        assert_eq!(json, "\"high\"");
        let parsed: Complexity = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, Complexity::High);
    }

    // CodeTask parsing tests

    fn sample_code_task_content() -> String {
        r#"# Task: Create User Model

## Description

Implement the User model with validation and database persistence.
This is a foundational task for the auth system.

## Technical Requirements

1. Create User struct with id, email, name fields
2. Implement validation for email format
3. Add database migration

## Acceptance Criteria

1. User struct is defined with required fields
2. Email validation rejects invalid formats
3. Database migration runs successfully
4. Unit tests pass with 100% coverage

## Dependencies

- Task 1.1 (database setup)
- task-02 (schema design)

## Metadata

- **Complexity**: High
- **Labels**: Core, Model, Database
"#
        .to_string()
    }

    fn minimal_code_task_content() -> String {
        r#"# Simple Task

Basic description here.
"#
        .to_string()
    }

    #[test]
    fn test_extract_title_task_format() {
        let content = "# Task: Create User Model\n\nSome content";
        let title = CodeTask::extract_title(content);
        assert_eq!(title, Some("Create User Model".to_string()));
    }

    #[test]
    fn test_extract_title_simple_heading() {
        let content = "# My Simple Heading\n\nSome content";
        let title = CodeTask::extract_title(content);
        assert_eq!(title, Some("My Simple Heading".to_string()));
    }

    #[test]
    fn test_extract_title_no_heading() {
        let content = "Just some content without a heading";
        let title = CodeTask::extract_title(content);
        assert_eq!(title, None);
    }

    #[test]
    fn test_extract_section_description() {
        let content = sample_code_task_content();
        let description = CodeTask::extract_section(&content, "Description");
        assert!(description.is_some());
        let desc = description.unwrap();
        assert!(desc.contains("User model"));
        assert!(desc.contains("validation"));
    }

    #[test]
    fn test_extract_section_not_found() {
        let content = "# Title\n\nNo sections here";
        let section = CodeTask::extract_section(content, "NonExistent");
        assert!(section.is_none());
    }

    #[test]
    fn test_extract_list_items_numbered() {
        let content = sample_code_task_content();
        let criteria = CodeTask::extract_list_items(&content, "Acceptance Criteria");
        assert_eq!(criteria.len(), 4);
        assert!(criteria[0].contains("User struct"));
        assert!(criteria[1].contains("Email validation"));
    }

    #[test]
    fn test_extract_list_items_empty_section() {
        let content = "# Title\n## Acceptance Criteria\n\n## Next Section";
        let criteria = CodeTask::extract_list_items(content, "Acceptance Criteria");
        assert!(criteria.is_empty());
    }

    #[test]
    fn test_extract_dependencies() {
        let content = sample_code_task_content();
        let deps = CodeTask::extract_dependencies(&content);
        assert!(!deps.is_empty());
        // Should find task-1.1 and task-02
        assert!(deps.iter().any(|d| d.contains("task")));
    }

    #[test]
    fn test_extract_dependencies_none() {
        let content = "# Title\n\nNo dependencies mentioned";
        let deps = CodeTask::extract_dependencies(content);
        assert!(deps.is_empty());
    }

    #[test]
    fn test_extract_complexity_high() {
        let content = "## Metadata\n- **Complexity**: High\n";
        let complexity = CodeTask::extract_complexity(content);
        assert_eq!(complexity, Some(Complexity::High));
    }

    #[test]
    fn test_extract_complexity_medium() {
        let content = "**Complexity**: Medium";
        let complexity = CodeTask::extract_complexity(content);
        assert_eq!(complexity, Some(Complexity::Medium));
    }

    #[test]
    fn test_extract_complexity_low() {
        let content = "- **Complexity**: Low\n";
        let complexity = CodeTask::extract_complexity(content);
        assert_eq!(complexity, Some(Complexity::Low));
    }

    #[test]
    fn test_extract_complexity_case_insensitive() {
        let content = "**Complexity**: HIGH";
        let complexity = CodeTask::extract_complexity(content);
        assert_eq!(complexity, Some(Complexity::High));
    }

    #[test]
    fn test_extract_complexity_not_found() {
        let content = "# Title\n\nNo complexity here";
        let complexity = CodeTask::extract_complexity(content);
        assert!(complexity.is_none());
    }

    #[test]
    fn test_extract_id_from_path() {
        let path = Path::new("task-01.code-task.md");
        let id = CodeTask::extract_id_from_path(path);
        assert_eq!(id, "task-01");

        let path2 = Path::new("/some/dir/feature-auth.code-task.md");
        let id2 = CodeTask::extract_id_from_path(path2);
        assert_eq!(id2, "feature-auth");
    }

    #[test]
    fn test_parse_full_content() {
        let content = sample_code_task_content();
        let path = Path::new("task-user-model.code-task.md");
        let task = CodeTask::parse(&content, path).unwrap();

        assert_eq!(task.id, "task-user-model");
        assert_eq!(task.title, "Create User Model");
        assert!(task.description.contains("User model"));
        assert_eq!(task.acceptance_criteria.len(), 4);
        assert!(!task.dependencies.is_empty());
        assert_eq!(task.complexity, Complexity::High);
    }

    #[test]
    fn test_parse_minimal_content() {
        let content = minimal_code_task_content();
        let path = Path::new("simple.code-task.md");
        let task = CodeTask::parse(&content, path).unwrap();

        assert_eq!(task.id, "simple");
        assert_eq!(task.title, "Simple Task");
        assert!(task.acceptance_criteria.is_empty());
        assert!(task.dependencies.is_empty());
        assert_eq!(task.complexity, Complexity::Medium); // default
    }

    // File I/O tests

    #[test]
    fn test_from_file() {
        let tmp_dir = TempDir::new().unwrap();
        let file_path = tmp_dir.path().join("test-task.code-task.md");

        fs::write(&file_path, sample_code_task_content()).unwrap();

        let task = CodeTask::from_file(&file_path).unwrap();

        assert_eq!(task.id, "test-task");
        assert_eq!(task.title, "Create User Model");
        assert_eq!(task.complexity, Complexity::High);
        assert_eq!(task.file_path, file_path);
    }

    #[test]
    fn test_from_file_not_found() {
        let result = CodeTask::from_file(Path::new("/nonexistent/path.md"));
        assert!(result.is_err());
    }

    #[test]
    fn test_from_directory() {
        let tmp_dir = TempDir::new().unwrap();

        // Create 5 code task files
        for i in 1..=5 {
            let content = format!(
                r#"# Task: Task {}

## Description
Description for task {}.

## Metadata
- **Complexity**: Medium
"#,
                i, i
            );
            let file_path = tmp_dir
                .path()
                .join(format!("task-{:02}.code-task.md", i));
            fs::write(&file_path, content).unwrap();
        }

        let tasks = CodeTask::from_directory(tmp_dir.path()).unwrap();

        assert_eq!(tasks.len(), 5);
        assert_eq!(tasks[0].title, "Task 1");
        assert_eq!(tasks[4].title, "Task 5");
    }

    #[test]
    fn test_from_directory_empty() {
        let tmp_dir = TempDir::new().unwrap();
        let tasks = CodeTask::from_directory(tmp_dir.path()).unwrap();
        assert!(tasks.is_empty());
    }

    #[test]
    fn test_from_directory_nonexistent() {
        let tasks = CodeTask::from_directory(Path::new("/nonexistent/path")).unwrap();
        assert!(tasks.is_empty());
    }

    #[test]
    fn test_from_directory_ignores_non_task_files() {
        let tmp_dir = TempDir::new().unwrap();

        // Create a code task file
        fs::write(
            tmp_dir.path().join("task-01.code-task.md"),
            "# Task: Real Task\n",
        )
        .unwrap();

        // Create non-task files
        fs::write(tmp_dir.path().join("README.md"), "# README\n").unwrap();
        fs::write(tmp_dir.path().join("notes.txt"), "some notes").unwrap();

        let tasks = CodeTask::from_directory(tmp_dir.path()).unwrap();
        assert_eq!(tasks.len(), 1);
        assert_eq!(tasks[0].title, "Real Task");
    }

    // to_task conversion tests

    #[test]
    fn test_to_task_conversion() {
        let code_task = CodeTask {
            id: "task-01".to_string(),
            file_path: PathBuf::from("task-01.code-task.md"),
            title: "Create User Model".to_string(),
            description: "Implement the user data model".to_string(),
            acceptance_criteria: vec!["Unit tests pass".to_string()],
            dependencies: vec!["task-00".to_string()],
            complexity: Complexity::High,
        };

        let task = code_task.to_task();

        assert_eq!(task.name, "Create User Model");
        assert_eq!(task.description, "Implement the user data model");
        assert!(!task.id.0.is_nil());
    }

    #[test]
    fn test_to_task_empty_description() {
        let code_task = CodeTask {
            id: "task-01".to_string(),
            file_path: PathBuf::from("task-01.code-task.md"),
            title: "Simple Task".to_string(),
            description: String::new(),
            acceptance_criteria: vec![],
            dependencies: vec![],
            complexity: Complexity::Low,
        };

        let task = code_task.to_task();

        assert_eq!(task.name, "Simple Task");
        assert_eq!(task.description, "");
    }

    // Serialization tests

    #[test]
    fn test_code_task_serialization() {
        let code_task = CodeTask {
            id: "task-01".to_string(),
            file_path: PathBuf::from("task-01.code-task.md"),
            title: "Create User Model".to_string(),
            description: "Implement user model".to_string(),
            acceptance_criteria: vec!["Tests pass".to_string()],
            dependencies: vec!["task-00".to_string()],
            complexity: Complexity::High,
        };

        let json = serde_json::to_string(&code_task).unwrap();
        let parsed: CodeTask = serde_json::from_str(&json).unwrap();

        assert_eq!(parsed.id, code_task.id);
        assert_eq!(parsed.title, code_task.title);
        assert_eq!(parsed.complexity, code_task.complexity);
    }

    // Edge case tests

    #[test]
    fn test_parse_with_bullet_list() {
        let content = r#"# Task: Bullet Test

## Acceptance Criteria

- First criterion
- Second criterion
* Third with asterisk
"#;
        let path = Path::new("bullet-test.code-task.md");
        let task = CodeTask::parse(content, path).unwrap();

        assert_eq!(task.acceptance_criteria.len(), 3);
        assert_eq!(task.acceptance_criteria[0], "First criterion");
        assert_eq!(task.acceptance_criteria[2], "Third with asterisk");
    }

    #[test]
    fn test_parse_with_mixed_list() {
        let content = r#"# Task: Mixed List Test

## Acceptance Criteria

1. First numbered
- Second bullet
2. Third numbered
* Fourth asterisk
"#;
        let path = Path::new("mixed-test.code-task.md");
        let task = CodeTask::parse(content, path).unwrap();

        assert_eq!(task.acceptance_criteria.len(), 4);
    }

    #[test]
    fn test_multiline_description() {
        let content = r#"# Task: Multiline Test

## Description

This is the first line.
This is the second line.
This is the third line.

## Next Section
"#;
        let path = Path::new("multiline.code-task.md");
        let task = CodeTask::parse(content, path).unwrap();

        assert!(task.description.contains("first line"));
        assert!(task.description.contains("second line"));
        assert!(task.description.contains("third line"));
    }
}
